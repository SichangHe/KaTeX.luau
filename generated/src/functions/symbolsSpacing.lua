-- ROBLOX upstream: https://github.com/SichangHe/KaTeX--KaTeX/blob/ec46deea/src/functions/symbolsSpacing.js
local Packages --[[ ROBLOX comment: must define Packages module ]]
local LuauPolyfill = require(Packages.LuauPolyfill)
local Boolean = LuauPolyfill.Boolean
-- @flow
local defineFunctionBuilders = require(script.Parent.Parent.defineFunction).defineFunctionBuilders
local buildCommon = require(script.Parent.Parent.buildCommon).default
local mathMLTree = require(script.Parent.Parent.mathMLTree).default
local ParseError = require(script.Parent.Parent.ParseError).default -- A map of CSS-based spacing functions to their CSS class.
local cssSpace: { [string]: string } =
	{ ["\\nobreak"] = "nobreak", ["\\allowbreak"] = "allowbreak" } -- A lookup table to determine whether a spacing function/symbol should be
-- treated like a regular space character.  If a symbol or command is a key
-- in this table, then it should be a regular space character.  Furthermore,
-- the associated value may have a `className` specifying an extra CSS class
-- to add to the created `span`.
local regularSpace: { [string]: { className: string? } } = {
	[" "] = {},
	["\\ "] = {},
	["~"] = { className = "nobreak" },
	["\\space"] = {},
	["\\nobreakspace"] = { className = "nobreak" },
} -- ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
-- src/symbols.js.
defineFunctionBuilders({
	type = "spacing",
	htmlBuilder = function(self, group, options)
		if Boolean.toJSBoolean(regularSpace:hasOwnProperty(group.text)) then
			local className = Boolean.toJSBoolean(regularSpace[tostring(group.text)].className)
					and regularSpace[tostring(group.text)].className
				or "" -- Spaces are generated by adding an actual space. Each of these
			-- things has an entry in the symbols table, so these will be turned
			-- into appropriate outputs.
			if group.mode == "text" then
				local ord = buildCommon:makeOrd(group, options, "textord")
				table.insert(ord.classes, className) --[[ ROBLOX CHECK: check if 'ord.classes' is an Array ]]
				return ord
			else
				return buildCommon:makeSpan(
					{ "mspace", className },
					{ buildCommon:mathsym(group.text, group.mode, options) },
					options
				)
			end
		elseif Boolean.toJSBoolean(cssSpace:hasOwnProperty(group.text)) then
			-- Spaces based on just a CSS class.
			return buildCommon:makeSpan({ "mspace", cssSpace[tostring(group.text)] }, {}, options)
		else
			error(ParseError.new(('Unknown type of space "%s"'):format(tostring(group.text))))
		end
	end,
	mathmlBuilder = function(self, group, options)
		local node
		if Boolean.toJSBoolean(regularSpace:hasOwnProperty(group.text)) then
			node = mathMLTree.MathNode.new("mtext", { mathMLTree.TextNode.new("\u{00a0}") })
		elseif Boolean.toJSBoolean(cssSpace:hasOwnProperty(group.text)) then
			-- CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
			return mathMLTree.MathNode.new("mspace")
		else
			error(ParseError.new(('Unknown type of space "%s"'):format(tostring(group.text))))
		end
		return node
	end,
})
